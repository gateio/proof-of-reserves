backup_plan_cluster:
  arg_name: cluster
  api_field: backupPlan.cluster
  required: true
  help_text: |
    Name of the cluster from which backups will be produced.
    Value must be entered as a relative name, e.g.:

    `projects/<project>/locations/<location>/clusters/<cluster>` for a regional cluster
    or
    `projects/<project>/zones/<zone>/clusters/<cluster>` for a zonal cluster.

backup_plan_description:
  arg_name: description
  api_field: backupPlan.description
  type: str
  help_text: |
    Optional text description for the backup plan.

deactivated:
  arg_name: deactivated
  api_field: backupPlan.deactivated
  type: bool
  help_text: |
    If set, no further changes may be made to this backup plan and no further backups may be created
    for this plan. Backup deletion is still allowed.

backup_delete_lock_days:
  arg_name: backup-delete-lock-days
  api_field: backupPlan.retentionPolicy.backupDeleteLockDays
  type: int
  help_text: |
    Number of days a backup produced via this plan cannot be deleted.

    Must be less than or equal to 90 days.  If 0, delete operations are allowed.

backup_retain_days:
  arg_name: backup-retain-days
  api_field: backupPlan.retentionPolicy.backupRetainDays
  help_text: |
    Number of days after which a backup produced via this plan is automatically deleted.

    If not set (value is 0), backups are not automatically deleted. If set, must be greater than the
    value for backup_delete_lock_days.

locked:
  arg_name: locked
  api_field: backupPlan.retentionPolicy.locked
  type: bool
  help_text: |
    If set, subsequent updates are not allowed to the backup plan's retention policy and this value
    cannot be changed.

cron_schedule:
  arg_name: cron-schedule
  api_field: backupPlan.backupSchedule.cronSchedule
  type: str
  # backupPlan.backupSchedule message should be nil by default.
  default: null
  # This only means when backup schedule is passed in, cron-schedule must be
  # passed in.
  required: true
  help_text: |
    Schedule on which backups will be automatically created.

    Use standard [cron](http://en.wikipedia.org/wiki/Cron#Overview) syntax. For example,
    `10 3 * * *` will automatically create a backup at 0310 every day. All times are interpreted as
    UTC. The minimum interval between scheduled backups is 10 minutes.

update_cron_schedule:
  arg_name: cron-schedule
  api_field: backupPlan.backupSchedule.cronSchedule
  type: str
  # backupPlan.backupSchedule message should be nil by default.
  default: null
  # This only means when backup schedule is passed in, cron-schedule must be
  # passed in.
  help_text: |
    Schedule on which backups will be automatically created.

    Use standard [cron](http://en.wikipedia.org/wiki/Cron#Overview) syntax. For example,
    `10 3 * * *` will automatically create a backup at 0310 every day. All times are interpreted as
    UTC. The minimum interval between scheduled backups is 10 minutes.

paused:
  arg_name: paused
  api_field: backupPlan.backupSchedule.paused
  type: bool
  # backupPlan.backupSchedule message should be nil by default.
  default: null
  help_text: |
    If set, automatic backup creation is suppressed. When unset, automatic backup creation resumes
    with the next scheduled create event.

all_namespaces:
  arg_name: all-namespaces
  api_field: backupPlan.backupConfig.allNamespaces
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessAllNamespaces
  type: bool
  action: store_true
  default: null
  help_text: |
    Scope of the backup includes resources from all namespaces.  Mutually exclusive with
    --selected-namespaces and --selected-applications.

selected_namespaces:
  arg_name: selected-namespaces
  api_field: backupPlan.backupConfig.selectedNamespaces.namespaces
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessSelectedNamespaces
  type: arg_list
  default: null
  help_text: |
    List of namespaces whose resources are included in the backup. Mutually exclusive with
    --all-namespaces and --selected-applications. e.g:
    --selected-namespaces=foo,bar

selected_applications:
  arg_name: selected-applications
  api_field: backupPlan.backupConfig.selectedApplications
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessSelectedApplications
  default: null
  help_text: |
    List of ProtectedApplication instances whose resources are included in the backup. Mutually
    exclusive with --all-namespaces and --selected-namespaces. e.g:
    --selected-applications=namespace1/foo,namespace2/bar

include_volume_data:
  arg_name: include-volume-data
  api_field: backupPlan.backupConfig.includeVolumeData
  type: bool
  default: false
  help_text: |
    If true, snapshots are created for PD volumes corresponding to PersistentVolumeClaims that fall
    within the scope. If unset, the default is false.

include_secrets:
  arg_name: include-secrets
  api_field: backupPlan.backupConfig.includeSecrets
  type: bool
  default: false
  help_text: |
    If true, secret resources are included in the backup if they fall within the scope. If unset,
    the default is false.

encryption_key:
  arg_name: encryption-key
  api_field: backupPlan.backupConfig.encryptionKey.gcpKmsEncryptionKey
  type: str
  help_text: |
    Encryption key used for encrypting the backup.

    At this time, only the Cloud Key Management Service (Cloud KMS) is supported.
    Value must be entered as a relative name, e.g.:
    `projects/<project>/locations/<location>/keyRings/<key-ring>/cryptoKeys/<key>`.

delete_lock_days:
  arg_name: delete-lock-days
  api_field: backup.deleteLockDays
  type: int
  help_text: |
    Delete lock days specifies the number of days from the create_time of this
    Backup before which deletion will be blocked. For automatically created
    Backup from schedule, this field will be set to the
    backupPlan.retentionPolicy.backupDeleteBlockDays.
    Manual creation of a backup with this field unspecified causes the service
    to use the value of backupPlan.RetentionPolicy.backupDeleteBlockDays.
    Creation of a backup with this field set to a value SMALLER than
    backupPlan.RetentionPolicy.backupDeleteBlockDays results in an invalid
    response from the service.
    This field MUST be an int value between 0-90(inclusive).
    This field may only be INCREASED in an update command, or an invalid
    response will be returned by the service.

retain_days:
  arg_name: retain-days
  api_field: backup.retainDays
  type: int
  help_text: |
    Retain days specifies the desired number of days from the createTime of
    this backup after which it will be automatically deleted.
    If not specified or set to 0, it means the backup will NOT be automatically
    deleted.
    For automatically created backup from schedule, this field will be set to
    the backupPlan.retentionPolicy.backupRetainDays.
    Manual creation of a backup with this field unspecified causes the service
    to use the value of backupPlan.retentionPolicy.backupRetainDays.
    Creation of a Backup with this field set to a value SMALLER than
    delete_lock_days results in an invalid response from the service.
    This field may ONLY be increased in an Update request, or an invalid
    response will be returned by the service immediately.
    Default to 0.

backup_description:
  arg_name: description
  api_field: backup.description
  help_text: |
    The description of the backup.

restore_plan_cluster:
  arg_name: cluster
  api_field: restorePlan.cluster
  required: true
  help_text: |
    The target cluster into which Restores created via this RestorePlan will restore data.
    NOTE: the cluster's region must be the same as the RestorePlan.

    Value must be entered as a relative name, e.g.:
    `projects/<project>/locations/<location>/clusters/<cluster>` for a regional cluster
    or
    `projects/<project>/zones/<zone>/clusters/<cluster>` for a zonal cluster.

restore_plan_backup_plan:
  arg_name: backup-plan
  api_field: restorePlan.backupPlan
  required: true
  help_text: |
    The BackupPlan from which Backups may be used as the source for Restores created via this
    RestorePlan.

    Value must be entered as a relative name, e.g.
    `projects/<project>/locations/<location>/backupPlans/<backupPlans>`.

restore_plan_description:
  arg_name: description
  api_field: restorePlan.description
  help_text: |
    The description of the restore plan.

volume_data_restore_policy:
  arg_name: volume-data-restore-policy
  api_field: restorePlan.restoreConfig.volumeDataRestorePolicy
  help_text: |
    Define how data is populated for restored volumes. If this flag is not specified,
    'no-volume-data-restoration' will be used.
  choices:
  - arg_value: restore-volume-data-from-backup
    help_text: |
      Selecting 'restore-volume-data-from-backup' means a new PV will be restored using the
      corresponding volume backup data in the Backup.
  - arg_value: reuse-volume-handle-from-backup
    help_text: |
      Selecting 'reuse-volume-handle-from-backup' means a PV will be pre-provisioned using the
      volume handle of the original PV in the Backup.
  - arg_value: no-volume-data-restoration
    help_text: |
      Selecting 'no-volume-data-restoration' means PV will not be restored. The restoration will
      ONLY restore selected PVCs and expects corresponding Kubernetes controllers to either
      dynamically provision blank PVs or bind them to pre-provisioned PVs created out-of-band.
  default: no-volume-data-restoration

cluster_resource_conflict_policy:
  arg_name: cluster-resource-conflict-policy
  api_field: restorePlan.restoreConfig.clusterResourceConflictPolicy
  help_text: |
    Define how to handle restore-time conflicts for cluster-scoped resources.
  choices:
  - arg_value: use-existing-version
    help_text: |
      Selecting 'use-existing-version' means no conflicting resources will be restored.
  - arg_value: use-backup-version
    help_text: |
      Selecting 'use-existing-version' means deleting the existing version of the conflicting
      resources before re-creating them from the Backup.

      Note that this is a dangerous option which
      could cause unintentional data loss if used inappropriately. For example, deleting a CRD will
      cause Kubernetes to delete all CRs of that type.

namespaced_resource_restore_mode:
  arg_name: namespaced-resource-restore-mode
  api_field: restorePlan.restoreConfig.namespacedResourceRestoreMode
  help_text: |
    Define how to handle restore-time conflicts for namespaced resources.
  choices:
  - arg_value: delete-and-restore
    help_text: |
      When conflicting top-level resources (either Namespaces or ProtectedApplications, depending
      upon the scope) are encountered, this will first trigger a delete of the conflicting resource
      AND ALL OF ITS REFERENCED RESOURCES (e.g., all resources in the Namespace or all resources
      referenced by the ProtectedApplication) before restoring the resources from the Backup. This
      mode should only be used when you are intending to revert some portion of a cluster to an
      earlier state.
  - arg_value: fail-on-conflict
    help_text: |
      If conflicting top-level resources (either Namespaces or ProtectedApplications, depending upon
      the scope) are encountered at the beginning of a restore process, the Restore will fail. If a
      conflict occurs during the restore process itself (e.g., because an out of band process
      creates conflicting resources), a conflict will be reported.

namespaced_resource_restore_mode_update:
  arg_name: namespaced-resource-restore-mode
  api_field: restorePlan.restoreConfig.namespacedResourceRestoreMode
  help_text: |
    Define how to handle restore-time conflicts for namespaced resources.
  choices:
  - arg_value: delete-and-restore
    help_text: |
      When conflicting top-level resources (either Namespaces or ProtectedApplications, depending
      upon the scope) are encountered, this will first trigger a delete of the conflicting resource
      AND ALL OF ITS REFERENCED RESOURCES (e.g., all resources in the Namespace or all resources
      referenced by the ProtectedApplication) before restoring the resources from the Backup. This
      mode should only be used when you are intending to revert some portion of a cluster to an
      earlier state.
  - arg_value: fail-on-conflict
    help_text: |
      If conflicting top-level resources (either Namespaces or ProtectedApplications, depending upon
      the scope) are encountered at the beginning of a restore process, the Restore will fail. If a
      conflict occurs during the restore process itself (e.g., because an out of band process
      creates conflicting resources), a conflict will be reported.

cluster_resource_restore_scope:
  arg_name: cluster-resource-restore-scope
  api_field: restorePlan.restoreConfig.clusterResourceRestoreScope
  action:
    deprecated:
      removed: true
      error: |
        Flag cluster-resource-restore-scope has been removed.
          Please use --cluster-resource-scope-selected-group-kinds instead.
  hidden: true
  type: arg_list
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessClusterResourceRestoreScope
  help_text: |
    List of cluster-scoped resource group kinds to restore from the backup. If specified,
    only the selected resources will be restored. The format of a resource is "<group>/<kind>", e.g.
    `storage.k8s.io/StorageClass` for StorageClass. Use an empty string for core API group.

cluster_resource_selected_group_kinds:
  arg_name: cluster-resource-scope-selected-group-kinds
  api_field: restorePlan.restoreConfig.clusterResourceRestoreScope
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessSelectedGroupKinds
  type: arg_list
  help_text: |
    List of cluster-scoped resource group kinds to restore from the backup. If specified,
    only the selected resources will be restored. The format of a resource is "<group>/<kind>", e.g.
    `storage.k8s.io/StorageClass` for StorageClass. Use an empty string for core API group.

cluster_resource_excluded_group_kinds:
  arg_name: cluster-resource-scope-excluded-group-kinds
  api_field: restorePlan.restoreConfig.clusterResourceRestoreScope
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessExcludedGroupKinds
  type: arg_list
  help_text: |
    List of cluster-scoped resource group kinds to NOT restore from the backup. If specified,
    all valid cluster-scoped resources will be restored except for those specified in the list.
    The format of a resource is "<group>/<kind>", e.g. `storage.k8s.io/StorageClass` for
    StorageClass. Use an empty string for core API group.

cluster_resource_all_group_kinds:
  arg_name: cluster-resource-scope-all-group-kinds
  api_field: restorePlan.restoreConfig.clusterResourceRestoreScope
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessAllGroupKinds
  type: bool
  action: store_true
  default: null
  help_text: |
    If true, all valid cluster-scoped resources will be restored.

cluster_resource_no_group_kinds:
  arg_name: cluster-resource-scope-no-group-kinds
  api_field: restorePlan.restoreConfig.clusterResourceRestoreScope
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessNoGroupKinds
  type: bool
  action: store_true
  default: null
  help_text: |
    If true, no cluster-scoped resources will be restored.

restore_plan_all_namespaces:
  arg_name: all-namespaces
  api_field: restorePlan.restoreConfig.allNamespaces
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessAllNamespaces
  type: bool
  action: store_true
  default: null
  help_text: |
    If true, restore all namespaced resources in the backup.

restore_plan_no_namespaces:
  arg_name: no-namespaces
  api_field: restorePlan.restoreConfig.noNamespaces
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessNoNamespaces
  type: bool
  action: store_true
  default: null
  help_text: |
    If true, do not restore any namespaced resources in the backup.

restore_plan_selected_namespaces:
  arg_name: selected-namespaces
  api_field: restorePlan.restoreConfig.selectedNamespaces.namespaces
  type: arg_list
  default: null
  help_text: |
    List of selected namespaces to restore. Only those namespaced resources belonging to a selected
    namespace are restored.

restore_plan_excluded_namespaces:
  arg_name: excluded-namespaces
  api_field: restorePlan.restoreConfig.excludedNamespaces.namespaces
  type: arg_list
  default: null
  help_text: |
    List of selected namespaces to skip. All namespaced resources in all namespaces excluding
    selected namespaces are restored.

restore_plan_selected_applications:
  arg_name: selected-applications
  api_field: restorePlan.restoreConfig.selectedApplications
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ProcessSelectedApplications
  default: null
  help_text: |
    List of selected applications to restore. Only those namespaced resources which belong to one of
    the selected applications are restored.

restore_plan_substitution_rules_file:
  arg_name: substitution-rules-file
  api_field: restorePlan.restoreConfig.substitutionRules
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ReadSubstitutionRuleFile
  help_text: |
    If provided, defines a set of resource transformations that will be applied to resources from
    the source backup before they are created in the target cluster.

restore_plan_transformation_rules_file:
  arg_name: transformation-rules-file
  api_field: restorePlan.restoreConfig.transformationRules
  processor: googlecloudsdk.command_lib.container.backup_restore.hooks:ReadTransformationRuleFile
  help_text: |
    If provided, defines a set of resource transformations that will be applied to resources from
    the source backup before they are created in the target cluster.

etag:
  arg_name: etag
  api_field: etag
  type: str
  help_text: |
    The etag is used for optimistic concurrency control as a way to help
    prevent simultaneous updates or deletes of a resource from overwriting each other.

backup_plan_etag:
  arg_name: etag
  api_field: backupPlan.etag
  type: str
  help_text: |
    The etag is used for optimistic concurrency control as a way to help
    prevent simultaneous updates or deletes of a resource from overwriting each other.

backup_etag:
  arg_name: etag
  api_field: backup.etag
  type: str
  help_text: |
    The etag is used for optimistic concurrency control as a way to help
    prevent simultaneous updates or deletes of a resource from overwriting each other.

restore_plan_etag:
  arg_name: etag
  api_field: restorePlan.etag
  type: str
  help_text: |
    The etag is used for optimistic concurrency control as a way to help
    prevent simultaneous updates or deletes of a resource from overwriting each other.

restore_etag:
  arg_name: etag
  api_field: restore.etag
  type: str
  help_text: |
    The etag is used for optimistic concurrency control as a way to help
    prevent simultaneous updates or deletes of a resource from overwriting each other.
